---
title: "tidychess"
author: "Josh Merrell"
output: 
  github_document:
    toc: true
---
# Introduction

**Terminology**  

  * __game data__  
  * __positional data__  
  * __PGN format__  
  * __FEN format__  
  * __matrix format__  
  * __tidy format__  
  * __positional mobility__  
  * __pathPrior__: planning to change the name to _theoretical mobility_. Lists the squares a piece can move on an empty chessboard.  
  * __Post functions__: planning to change the name to _ingame_ functions. They were named for _aposteriori_, and they list the squares to which a piece can move from a given position.  


# Exploration of Functions
**Setup**
```{r setup}
invisible(lapply(list.files("R", "\\.R$", full.names = T), source))
```

**The mobility_piece function**
```{r mobility_piece}
# if position_vec is not passed as an input, 
# it is assumed that no other pieces are on the board
mobility_piece(piece = "bishop", square = "e5")

# if board is empty, specified piece is not on specified square:
mobility_piece(piece = "white pawn", square = "a2", position_vec = empty())

# white pawns travel up and black pawns travel down
mobility_piece(piece = "black pawn", square = "e5")
mobility_piece(piece = "white pawn", square = "e5")

# pawns of unspecified color might go either direction
mobility_piece(piece = "pawn", square = "e5")

# mobility_piece() piece type from position_vec & square:
mobility_piece(square = "a2", position_vec = setup(includeEmpty = F)[1,])

# if piece input conflicts with square & position_vec inputs, it is overriden:
mobility_piece(square = "a2", 
               position_vec = setup(includeEmpty = F)[1,], 
               piece = "white rook")
```
**compare post & prior**
```{r mobility_board, eval=T}
mobility_board(position_vec = setup())
patterns <- c("white bishops" = "white bishop",
              "black knights"="black knight",
              "pawns"="pawn")
pieces <- unique(unlist(setup()[2,]));  pieces <- pieces[!is.na(pieces)]
mobility_board(position_vec = setup(), patterns = patterns)
mobility_board(position_vec = setup(), patterns = pieces)
rm(patterns, pieces)
```

**new_position**
```{r new_position, eval=F}
positions <- setup()
positions <- rbind(positions, new_position(new_pgn = "1.e3",
                                           position_vec = positions))
positions[,c("e2","e3")]
rm(positions)
```

**to.FEN**
```{r to.FEN, eval=F}
# returns empty string in response to empty chessboard
to.FEN(empty())

# returns standard string for standard setup
to.FEN(setup())
```

# Chess Data
**Bash-managed scraping**
```{r bash-scrape, engine="bash", eval=F}
#!/bin/bash
# obtain list of previously stored data to avoid duplication
aws s3 ls s3://jbchess/data --recursive > temp.txt

# iterate through a range of numbers
for n in $(seq 200 1000)
do

  # adjust both numbers to the proper order of magnitude
	first=$(($n*1000+1))
	last=$(($n*1000+1000))
	# record the beginning & ending range of numbers; include a timestamp
	echo start $first $last $(date)
	
	# pass the range of numbers to the scrape.chess.com function
	Rscript R/scrape.chess.com.R $first $last
	
	# move the acquired data to the bucket
	aws s3 mv data s3://jbchess/data --recursive
done
```

**acquire sample of chess data**
```{r s3-retrieve, engine="bash", eval=F}
# use the shell to extract sample of chess games:
aws s3 cp "s3://jbchess/data/chess.com IDs 1-1000.csv" "data/chess.com IDs 1-1000.csv"
```

**example of positional data**
```{r xmpl-pos}
DATA <- read.csv("data/chess.com IDs 1-1000.csv", stringsAsFactors = F)
DFSummary(DATA)
positions <- setup()
pgn <- strsplit(DATA[1,"pgn"]," ")[[1]]
pgn <- pgn[!grepl(">", pgn)]
pgn[seq(2,length(pgn),2)] <- paste0(seq(1,length(pgn)/2),
                                    "...",
                                    pgn[seq(2,length(pgn),2)])
for(n in 1:length(pgn)){
  positions <- rbind(positions,
                     new_position(pgn[n], positions))
}; rm(n)
for(n in 2:nrow(positions)){
  positions[n, "FEN"] <- to.FEN(positions[1:n,1:64])
}
print(cbind(row.names(positions),positions$FEN))

apply(positions[-1,], 1, mobility_board, 
      patterns = c(white="white", black="black", pawns="pawn", 
                   knights="knight", bishops="bishop", rooks="rook", 
                   queens="queen", kings="king"))
rm(positions, pgn, DATA)
```

**iterating through positional data
```{r itr-pos, eval=F}
DATA <- read.csv("data/chess.com IDs 1-1000.csv", stringsAsFactors = F)
for(n in grep(".", DATA$pgn)){
  positions <- setup()
  pgn <- strsplit(DATA[n,"pgn"], " ")[[1]]
  pgn <- pgn[!grepl(">", pgn)]
  pgn[seq(2,length(pgn),2)] <- paste0(seq(1,length(pgn)/2),
                                    "...",
                                    pgn[seq(2,length(pgn),2)])
  for(i in 1:length(pgn)){
    positions <- rbind(positions,
                       new_position(pgn[i], positions))
  }; rm(i)
  DATA[n,"FEN"] <- to.FEN(position_df=positions[,1:64])
  print(n)
}; rm(n, pgn)
table(nchar(DATA$FEN))
```

# Issues

```{r setup 2}
rm(list=ls())
invisible(lapply(list.files("R", "\\.R$", full.names = T), source))
```

**Issue 5**
Function *new_positions* does not vacate position during pawn promotion.
Link: [o_7](https://www.chess.com/games/view/7)
```{r xmpl-pos}
DATA <- read.csv("data/chess.com IDs 1-1000.csv", stringsAsFactors = F)
positions <- setup()
pgn <- strsplit(DATA[18,"pgn"]," ")[[1]]
pgn <- pgn[!grepl(">", pgn)]
pgn[seq(2,length(pgn),2)] <- paste0(seq(1,length(pgn)/2),
                                    "...",
                                    pgn[seq(2,length(pgn),2)])
# n <- 1
# while(pgn[n]!="31...b1Q+"){
for(n in 1:length(pgn)){
  temp <- new_position(pgn[n], positions)
  if(class(temp[,1])=="factor"){stop("strings are factors")}
  if(class(temp)!="data.frame"){stop("not a data frame")}
  positions <- rbind(positions,
                     temp)
  n <- n + 1
}
# this board is correct:
board(positions)
# b2 moves to b1 and gets promoted to queen, then b2 should be vacant:
board(new_position("31...b1Q+",positions))
```

