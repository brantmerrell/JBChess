---
title: "tidychess"
author: "Josh Merrell"
output: 
  github_document:
    toc: true
---
# Introduction

**Terminology**  

  * __game data__  
  * __positional data__  
  * __PGN format__  
  * __FEN format__  
  * __matrix format__  
  * __tidy format__  
  * __positional mobility__  
  * __pathPrior__: planning to change the name to _theoretical mobility_. Lists the squares a piece can move on an empty chessboard.  
  * __Post functions__: planning to change the name to _ingame_ functions. They were named for _aposteriori_, and they list the squares to which a piece can move from a given position.  

# Data Acquisition
**Bash-managed scraping**
```{r bash-scrape, engine="bash", eval=F}
#!/bin/bash
# obtain list of previously stored data to avoid duplication
aws s3 ls s3://jbchess/data --recursive > temp.txt

# iterate through a range of numbers
for n in $(seq 200 1000)
do

  # adjust both numbers to the proper order of magnitude
	first=$(($n*1000+1))
	last=$(($n*1000+1000))
	# record the beginning & ending range of numbers; include a timestamp
	echo start $first $last $(date)
	
	# pass the range of numbers to the scrape.chess.com function
	Rscript R/scrape.chess.com.R $first $last
	
	# move the acquired data to the bucket
	aws s3 mv data s3://jbchess/data --recursive
done
```

# Exploration of Functions
**Setup**
```{r setup}
invisible(lapply(list.files("R", "\\.R$", full.names = T), source))
```

**The mobility_piece function**
```{r mobility_piece}
# if position_vec is not passed as an input, 
# it is assumed that no other pieces are on the board
mobility_piece(piece = "bishop", square = "e5")

# if board is empty, specified piece is not on specified square:
mobility_piece(piece = "white pawn", square = "a2", position_vec = empty())

# white pawns travel up and black pawns travel down
mobility_piece(piece = "black pawn", square = "e5")
mobility_piece(piece = "white pawn", square = "e5")

# pawns of unspecified color might go either direction
mobility_piece(piece = "pawn", square = "e5")

# mobility_piece() piece type from position_vec & square:
mobility_piece(square = "a2", position_vec = setup(includeEmpty = F)[1,])

# if piece input conflicts with square & position_vec inputs, it is overriden:
mobility_piece(square = "a2", 
               position_vec = setup(includeEmpty = F)[1,], 
               piece = "white rook")
```
**compare post & prior**
```{r mobility_board, eval=T}
mobility_board(position_vec = setup())
```

Because of the game_pgn input, *pathPost.* knows that the piece on h2 is a white knight, and that it cannot move to **d2** because that space is occupied by another pawn.
```{r, eval=F}
for(n in 1:nrow(moves)){
  pgn <- paste("xmpl1",
               as.vector(moves[n,"pgn"]),
               sep="_")
  if(!pgn %in% row.names(position)){
    position<-rbind(position, newPosition(new_pgn = pgn))
  }
}
rownames(position)
```

# Exploration of Chessboards
